{
  "version": 3,
  "sources": ["../../katex/dist/contrib/auto-render.mjs"],
  "sourcesContent": ["import katex from '../katex.mjs';\r\n\r\n/* eslint no-constant-condition:0 */\r\nvar findEndOfMath = function findEndOfMath(delimiter, text, startIndex) {\r\n  // Adapted from\r\n  // https://github.com/Khan/perseus/blob/master/src/perseus-markdown.jsx\r\n  var index = startIndex;\r\n  var braceLevel = 0;\r\n  var delimLength = delimiter.length;\r\n\r\n  while (index < text.length) {\r\n    var character = text[index];\r\n\r\n    if (braceLevel <= 0 && text.slice(index, index + delimLength) === delimiter) {\r\n      return index;\r\n    } else if (character === \"\\\\\") {\r\n      index++;\r\n    } else if (character === \"{\") {\r\n      braceLevel++;\r\n    } else if (character === \"}\") {\r\n      braceLevel--;\r\n    }\r\n\r\n    index++;\r\n  }\r\n\r\n  return -1;\r\n};\r\n\r\nvar escapeRegex = function escapeRegex(string) {\r\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\r\n};\r\n\r\nvar amsRegex = /^\\\\begin{/;\r\n\r\nvar splitAtDelimiters = function splitAtDelimiters(text, delimiters) {\r\n  var index;\r\n  var data = [];\r\n  var regexLeft = new RegExp(\"(\" + delimiters.map(x => escapeRegex(x.left)).join(\"|\") + \")\");\r\n\r\n  while (true) {\r\n    index = text.search(regexLeft);\r\n\r\n    if (index === -1) {\r\n      break;\r\n    }\r\n\r\n    if (index > 0) {\r\n      data.push({\r\n        type: \"text\",\r\n        data: text.slice(0, index)\r\n      });\r\n      text = text.slice(index); // now text starts with delimiter\r\n    } // ... so this always succeeds:\r\n\r\n\r\n    var i = delimiters.findIndex(delim => text.startsWith(delim.left));\r\n    index = findEndOfMath(delimiters[i].right, text, delimiters[i].left.length);\r\n\r\n    if (index === -1) {\r\n      break;\r\n    }\r\n\r\n    var rawData = text.slice(0, index + delimiters[i].right.length);\r\n    var math = amsRegex.test(rawData) ? rawData : text.slice(delimiters[i].left.length, index);\r\n    data.push({\r\n      type: \"math\",\r\n      data: math,\r\n      rawData,\r\n      display: delimiters[i].display\r\n    });\r\n    text = text.slice(index + delimiters[i].right.length);\r\n  }\r\n\r\n  if (text !== \"\") {\r\n    data.push({\r\n      type: \"text\",\r\n      data: text\r\n    });\r\n  }\r\n\r\n  return data;\r\n};\r\n\r\n/* eslint no-console:0 */\r\n/* Note: optionsCopy is mutated by this method. If it is ever exposed in the\r\n * API, we should copy it before mutating.\r\n */\r\n\r\nvar renderMathInText = function renderMathInText(text, optionsCopy) {\r\n  var data = splitAtDelimiters(text, optionsCopy.delimiters);\r\n\r\n  if (data.length === 1 && data[0].type === 'text') {\r\n    // There is no formula in the text.\r\n    // Let's return null which means there is no need to replace\r\n    // the current text node with a new one.\r\n    return null;\r\n  }\r\n\r\n  var fragment = document.createDocumentFragment();\r\n\r\n  for (var i = 0; i < data.length; i++) {\r\n    if (data[i].type === \"text\") {\r\n      fragment.appendChild(document.createTextNode(data[i].data));\r\n    } else {\r\n      var span = document.createElement(\"span\");\r\n      var math = data[i].data; // Override any display mode defined in the settings with that\r\n      // defined by the text itself\r\n\r\n      optionsCopy.displayMode = data[i].display;\r\n\r\n      try {\r\n        if (optionsCopy.preProcess) {\r\n          math = optionsCopy.preProcess(math);\r\n        }\r\n\r\n        katex.render(math, span, optionsCopy);\r\n      } catch (e) {\r\n        if (!(e instanceof katex.ParseError)) {\r\n          throw e;\r\n        }\r\n\r\n        optionsCopy.errorCallback(\"KaTeX auto-render: Failed to parse `\" + data[i].data + \"` with \", e);\r\n        fragment.appendChild(document.createTextNode(data[i].rawData));\r\n        continue;\r\n      }\r\n\r\n      fragment.appendChild(span);\r\n    }\r\n  }\r\n\r\n  return fragment;\r\n};\r\n\r\nvar renderElem = function renderElem(elem, optionsCopy) {\r\n  for (var i = 0; i < elem.childNodes.length; i++) {\r\n    var childNode = elem.childNodes[i];\r\n\r\n    if (childNode.nodeType === 3) {\r\n      // Text node\r\n      // Concatenate all sibling text nodes.\r\n      // Webkit browsers split very large text nodes into smaller ones,\r\n      // so the delimiters may be split across different nodes.\r\n      var textContentConcat = childNode.textContent;\r\n      var sibling = childNode.nextSibling;\r\n      var nSiblings = 0;\r\n\r\n      while (sibling && sibling.nodeType === Node.TEXT_NODE) {\r\n        textContentConcat += sibling.textContent;\r\n        sibling = sibling.nextSibling;\r\n        nSiblings++;\r\n      }\r\n\r\n      var frag = renderMathInText(textContentConcat, optionsCopy);\r\n\r\n      if (frag) {\r\n        // Remove extra text nodes\r\n        for (var j = 0; j < nSiblings; j++) {\r\n          childNode.nextSibling.remove();\r\n        }\r\n\r\n        i += frag.childNodes.length - 1;\r\n        elem.replaceChild(frag, childNode);\r\n      } else {\r\n        // If the concatenated text does not contain math\r\n        // the siblings will not either\r\n        i += nSiblings;\r\n      }\r\n    } else if (childNode.nodeType === 1) {\r\n      (function () {\r\n        // Element node\r\n        var className = ' ' + childNode.className + ' ';\r\n        var shouldRender = optionsCopy.ignoredTags.indexOf(childNode.nodeName.toLowerCase()) === -1 && optionsCopy.ignoredClasses.every(x => className.indexOf(' ' + x + ' ') === -1);\r\n\r\n        if (shouldRender) {\r\n          renderElem(childNode, optionsCopy);\r\n        }\r\n      })();\r\n    } // Otherwise, it's something else, and ignore it.\r\n\r\n  }\r\n};\r\n\r\nvar renderMathInElement = function renderMathInElement(elem, options) {\r\n  if (!elem) {\r\n    throw new Error(\"No element provided to render\");\r\n  }\r\n\r\n  var optionsCopy = {}; // Object.assign(optionsCopy, option)\r\n\r\n  for (var option in options) {\r\n    if (options.hasOwnProperty(option)) {\r\n      optionsCopy[option] = options[option];\r\n    }\r\n  } // default options\r\n\r\n\r\n  optionsCopy.delimiters = optionsCopy.delimiters || [{\r\n    left: \"$$\",\r\n    right: \"$$\",\r\n    display: true\r\n  }, {\r\n    left: \"\\\\(\",\r\n    right: \"\\\\)\",\r\n    display: false\r\n  }, // LaTeX uses $…$, but it ruins the display of normal `$` in text:\r\n  // {left: \"$\", right: \"$\", display: false},\r\n  // $ must come after $$\r\n  // Render AMS environments even if outside $$…$$ delimiters.\r\n  {\r\n    left: \"\\\\begin{equation}\",\r\n    right: \"\\\\end{equation}\",\r\n    display: true\r\n  }, {\r\n    left: \"\\\\begin{align}\",\r\n    right: \"\\\\end{align}\",\r\n    display: true\r\n  }, {\r\n    left: \"\\\\begin{alignat}\",\r\n    right: \"\\\\end{alignat}\",\r\n    display: true\r\n  }, {\r\n    left: \"\\\\begin{gather}\",\r\n    right: \"\\\\end{gather}\",\r\n    display: true\r\n  }, {\r\n    left: \"\\\\begin{CD}\",\r\n    right: \"\\\\end{CD}\",\r\n    display: true\r\n  }, {\r\n    left: \"\\\\[\",\r\n    right: \"\\\\]\",\r\n    display: true\r\n  }];\r\n  optionsCopy.ignoredTags = optionsCopy.ignoredTags || [\"script\", \"noscript\", \"style\", \"textarea\", \"pre\", \"code\", \"option\"];\r\n  optionsCopy.ignoredClasses = optionsCopy.ignoredClasses || [];\r\n  optionsCopy.errorCallback = optionsCopy.errorCallback || console.error; // Enable sharing of global macros defined via `\\gdef` between different\r\n  // math elements within a single call to `renderMathInElement`.\r\n\r\n  optionsCopy.macros = optionsCopy.macros || {};\r\n  renderElem(elem, optionsCopy);\r\n};\r\n\r\nexport { renderMathInElement as default };\r\n"],
  "mappings": ";;;;;;AAGA,IAAI,gBAAgB,SAASA,eAAc,WAAW,MAAM,YAAY;AAGtE,MAAI,QAAQ;AACZ,MAAI,aAAa;AACjB,MAAI,cAAc,UAAU;AAE5B,SAAO,QAAQ,KAAK,QAAQ;AAC1B,QAAI,YAAY,KAAK,KAAK;AAE1B,QAAI,cAAc,KAAK,KAAK,MAAM,OAAO,QAAQ,WAAW,MAAM,WAAW;AAC3E,aAAO;AAAA,IACT,WAAW,cAAc,MAAM;AAC7B;AAAA,IACF,WAAW,cAAc,KAAK;AAC5B;AAAA,IACF,WAAW,cAAc,KAAK;AAC5B;AAAA,IACF;AAEA;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAI,cAAc,SAASC,aAAY,QAAQ;AAC7C,SAAO,OAAO,QAAQ,yBAAyB,MAAM;AACvD;AAEA,IAAI,WAAW;AAEf,IAAI,oBAAoB,SAASC,mBAAkB,MAAM,YAAY;AACnE,MAAI;AACJ,MAAI,OAAO,CAAC;AACZ,MAAI,YAAY,IAAI,OAAO,MAAM,WAAW,IAAI,OAAK,YAAY,EAAE,IAAI,CAAC,EAAE,KAAK,GAAG,IAAI,GAAG;AAEzF,SAAO,MAAM;AACX,YAAQ,KAAK,OAAO,SAAS;AAE7B,QAAI,UAAU,IAAI;AAChB;AAAA,IACF;AAEA,QAAI,QAAQ,GAAG;AACb,WAAK,KAAK;AAAA,QACR,MAAM;AAAA,QACN,MAAM,KAAK,MAAM,GAAG,KAAK;AAAA,MAC3B,CAAC;AACD,aAAO,KAAK,MAAM,KAAK;AAAA,IACzB;AAGA,QAAI,IAAI,WAAW,UAAU,WAAS,KAAK,WAAW,MAAM,IAAI,CAAC;AACjE,YAAQ,cAAc,WAAW,CAAC,EAAE,OAAO,MAAM,WAAW,CAAC,EAAE,KAAK,MAAM;AAE1E,QAAI,UAAU,IAAI;AAChB;AAAA,IACF;AAEA,QAAI,UAAU,KAAK,MAAM,GAAG,QAAQ,WAAW,CAAC,EAAE,MAAM,MAAM;AAC9D,QAAI,OAAO,SAAS,KAAK,OAAO,IAAI,UAAU,KAAK,MAAM,WAAW,CAAC,EAAE,KAAK,QAAQ,KAAK;AACzF,SAAK,KAAK;AAAA,MACR,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA,SAAS,WAAW,CAAC,EAAE;AAAA,IACzB,CAAC;AACD,WAAO,KAAK,MAAM,QAAQ,WAAW,CAAC,EAAE,MAAM,MAAM;AAAA,EACtD;AAEA,MAAI,SAAS,IAAI;AACf,SAAK,KAAK;AAAA,MACR,MAAM;AAAA,MACN,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAOA,IAAI,mBAAmB,SAASC,kBAAiB,MAAM,aAAa;AAClE,MAAI,OAAO,kBAAkB,MAAM,YAAY,UAAU;AAEzD,MAAI,KAAK,WAAW,KAAK,KAAK,CAAC,EAAE,SAAS,QAAQ;AAIhD,WAAO;AAAA,EACT;AAEA,MAAI,WAAW,SAAS,uBAAuB;AAE/C,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,QAAI,KAAK,CAAC,EAAE,SAAS,QAAQ;AAC3B,eAAS,YAAY,SAAS,eAAe,KAAK,CAAC,EAAE,IAAI,CAAC;AAAA,IAC5D,OAAO;AACL,UAAI,OAAO,SAAS,cAAc,MAAM;AACxC,UAAI,OAAO,KAAK,CAAC,EAAE;AAGnB,kBAAY,cAAc,KAAK,CAAC,EAAE;AAElC,UAAI;AACF,YAAI,YAAY,YAAY;AAC1B,iBAAO,YAAY,WAAW,IAAI;AAAA,QACpC;AAEA,cAAM,OAAO,MAAM,MAAM,WAAW;AAAA,MACtC,SAAS,GAAG;AACV,YAAI,EAAE,aAAa,MAAM,aAAa;AACpC,gBAAM;AAAA,QACR;AAEA,oBAAY,cAAc,yCAAyC,KAAK,CAAC,EAAE,OAAO,WAAW,CAAC;AAC9F,iBAAS,YAAY,SAAS,eAAe,KAAK,CAAC,EAAE,OAAO,CAAC;AAC7D;AAAA,MACF;AAEA,eAAS,YAAY,IAAI;AAAA,IAC3B;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAI,aAAa,SAASC,YAAW,MAAM,aAAa;AACtD,WAAS,IAAI,GAAG,IAAI,KAAK,WAAW,QAAQ,KAAK;AAC/C,QAAI,YAAY,KAAK,WAAW,CAAC;AAEjC,QAAI,UAAU,aAAa,GAAG;AAK5B,UAAI,oBAAoB,UAAU;AAClC,UAAI,UAAU,UAAU;AACxB,UAAI,YAAY;AAEhB,aAAO,WAAW,QAAQ,aAAa,KAAK,WAAW;AACrD,6BAAqB,QAAQ;AAC7B,kBAAU,QAAQ;AAClB;AAAA,MACF;AAEA,UAAI,OAAO,iBAAiB,mBAAmB,WAAW;AAE1D,UAAI,MAAM;AAER,iBAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,oBAAU,YAAY,OAAO;AAAA,QAC/B;AAEA,aAAK,KAAK,WAAW,SAAS;AAC9B,aAAK,aAAa,MAAM,SAAS;AAAA,MACnC,OAAO;AAGL,aAAK;AAAA,MACP;AAAA,IACF,WAAW,UAAU,aAAa,GAAG;AACnC,OAAC,WAAY;AAEX,YAAI,YAAY,MAAM,UAAU,YAAY;AAC5C,YAAI,eAAe,YAAY,YAAY,QAAQ,UAAU,SAAS,YAAY,CAAC,MAAM,MAAM,YAAY,eAAe,MAAM,OAAK,UAAU,QAAQ,MAAM,IAAI,GAAG,MAAM,EAAE;AAE5K,YAAI,cAAc;AAChB,UAAAA,YAAW,WAAW,WAAW;AAAA,QACnC;AAAA,MACF,GAAG;AAAA,IACL;AAAA,EAEF;AACF;AAEA,IAAI,sBAAsB,SAASC,qBAAoB,MAAM,SAAS;AACpE,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AAEA,MAAI,cAAc,CAAC;AAEnB,WAAS,UAAU,SAAS;AAC1B,QAAI,QAAQ,eAAe,MAAM,GAAG;AAClC,kBAAY,MAAM,IAAI,QAAQ,MAAM;AAAA,IACtC;AAAA,EACF;AAGA,cAAY,aAAa,YAAY,cAAc;AAAA,IAAC;AAAA,MAClD,MAAM;AAAA,MACN,OAAO;AAAA,MACP,SAAS;AAAA,IACX;AAAA,IAAG;AAAA,MACD,MAAM;AAAA,MACN,OAAO;AAAA,MACP,SAAS;AAAA,IACX;AAAA;AAAA;AAAA;AAAA;AAAA,IAIA;AAAA,MACE,MAAM;AAAA,MACN,OAAO;AAAA,MACP,SAAS;AAAA,IACX;AAAA,IAAG;AAAA,MACD,MAAM;AAAA,MACN,OAAO;AAAA,MACP,SAAS;AAAA,IACX;AAAA,IAAG;AAAA,MACD,MAAM;AAAA,MACN,OAAO;AAAA,MACP,SAAS;AAAA,IACX;AAAA,IAAG;AAAA,MACD,MAAM;AAAA,MACN,OAAO;AAAA,MACP,SAAS;AAAA,IACX;AAAA,IAAG;AAAA,MACD,MAAM;AAAA,MACN,OAAO;AAAA,MACP,SAAS;AAAA,IACX;AAAA,IAAG;AAAA,MACD,MAAM;AAAA,MACN,OAAO;AAAA,MACP,SAAS;AAAA,IACX;AAAA,EAAC;AACD,cAAY,cAAc,YAAY,eAAe,CAAC,UAAU,YAAY,SAAS,YAAY,OAAO,QAAQ,QAAQ;AACxH,cAAY,iBAAiB,YAAY,kBAAkB,CAAC;AAC5D,cAAY,gBAAgB,YAAY,iBAAiB,QAAQ;AAGjE,cAAY,SAAS,YAAY,UAAU,CAAC;AAC5C,aAAW,MAAM,WAAW;AAC9B;",
  "names": ["findEndOfMath", "escapeRegex", "splitAtDelimiters", "renderMathInText", "renderElem", "renderMathInElement"]
}
